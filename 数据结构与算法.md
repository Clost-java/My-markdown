# 数据结构与算法

**数据结构**

数据结构包括线性结构和非线性结构

**线性结构：**

- 线性结构特点==数据元素之间存在一对一的==线性关系
- 线性结构有两种不同的存储结构，顺序存储结构（数组）和链式存储结构（链表）顺序存储的线性表成为顺序表，顺序表中的==存储元素是连续的==
- 链式存储的线性表成为链表，链表的存储元素不一定是连续的，元素节点中存放的数据元素以及相邻元素的地址信息
- 线性结构常见的有：数组、队列、栈、链表

**非线性结构**：

- 非线性结构包括：二维数组、多维数组、广义表、图结构

### 稀疏数组：

- 一个数组中大部分元素是0，或者为同一个值时，可以用稀疏数组来保存该数组

- 记录数组==一共有几行几列==有多少个不同值

- 把不同值得行列信息记录到一个小规模的数组中，从而==缩小程序的规模==

- 代码实现

  ```java
  package com.clost.sparsearray;
  
  /**
   * @author clost
   * @date 2022/8/31 9:51
   */
  public class sparseArray {
  
      public static void main(String[] args) {
  
          /**
           * 二维数组转稀疏数组，把二维数组中非零数据的位置记录到一个新的数组中
           * 1.稀疏数组第一行存放二维数组的行数、列数、非零值得个数
           * 其余的部分分别存储二维数组中非零数据的行、列、值
           */
          //创建二维数组11 * 11
          int[][] chessArray = new int[11][11];
          chessArray[1][2] = 1;
          chessArray[2][3] = 1;
  
          //遍历初始数组
          System.out.println("初始二维数组是:");
          for (int[] row : chessArray) {
              for (int data : row) {
                  System.out.print(data + "\t");
              }
              System.out.println();
  
          }
  
          //先遍历二维数组，得到非0数据的个数
          int sum = 0;
  
          for (int i = 0; i < chessArray.length; i++) {
              for (int j = 0; j < chessArray[i].length; j++) {
                  if (chessArray[i][j] != 0) {
                      sum++;
                  }
              }
          }
  
          System.out.println("sum=" + sum);
          //创建稀疏数组
          int[][] sparseArray = new int[sum + 1][3];
          sparseArray[0][0] = chessArray.length;
          sparseArray[0][1] = chessArray[0].length;
          sparseArray[0][2] = sum;
  
          int count = 0;
          for (int i = 0; i < chessArray.length; i++) {
              for (int j = 0; j < chessArray[i].length; j++) {
                  if (chessArray[i][j] != 0) {
                      count++;
                      sparseArray[count][0] = i;
                      sparseArray[count][1] = j;
                      sparseArray[count][2] = chessArray[i][j];
  
                  }
              }
          }
          System.out.println("二维数组转化后的稀疏数组");
          for (int[] row : sparseArray) {
              for (int data : row) {
                  System.out.print(data + "\t");
              }
              System.out.println();
  
          }
  
          /**
           * 读取稀疏数组，转化为二维数组
           * 1.先读取稀疏数组的第一行，获取二维数组的行数，列数，创建二维数组
           * 2.读取稀疏数组中非零数据的位置信息，赋给二维数组
           */
  
          //读取第一行数组
          int [][] chessArray2 = new int[sparseArray[0][0]][sparseArray[0][1]];
  
          //遍历稀疏数组，读取数据的行、列、值的信息
          for (int i = 1; i < sparseArray.length; i++) {
              int row = sparseArray[i][0];
              int col = sparseArray[i][1];
              int val = sparseArray[i][2];
              chessArray2[row][col] = val;
          }
          System.out.println("还原后的二维组为:");
          for (int[] row : chessArray2) {
              for (int data : row) {
                  System.out.print(data + "\t");
              }
              System.out.println();
  
          }
  
      }
  }
  
  ```
  

### 队列：

- 队列是一个有序列表，可以用==数组==和==链表==实现

- 遵循==先进先出==

- 数组模拟队列实现

  ```java
  package com.clost.sparsearray;
  
  import java.util.Scanner;
  
  /**
   * @author clost
   * @date 2022/9/3 9:38
   */
  public class ArrayQueueDemo {
  
  
      public static void main(String[] args) {
  
          //创建队列
  
          ArrayQueue arrayQueue = new ArrayQueue(3);
          char key = ' '; //接收用户输入
          Scanner scanner = new Scanner(System.in);
          int choice;
          boolean flag = true;
          while (flag) {
              System.out.println("1.添加数据进队列");
              System.out.println("2.取出数据");
              System.out.println("3.显示队列中的所有数据");
              System.out.println("4.显示队列头数据");
              System.out.println("5.退出");
              System.out.println("请输选择你的操作");
              choice = scanner.nextInt();
  
              switch (choice) {
                  case 1 -> {
                      System.out.println("请输入你要添加的数据");
                      arrayQueue.addQueue(scanner.nextInt());
                  }
                  case 2 -> System.out.println(arrayQueue.getQueue());
                  case 3 -> arrayQueue.showQueue();
                  case 4 -> arrayQueue.headQueue();
                  case 5 -> flag = false;
                  default -> System.out.println("输入有误，请重新输入");
              }
          }
      }
  
  }
  
  
  //使用数组模拟队列
  class ArrayQueue {
      private int MaxSize;//数组最大容量
      private int front; //队列头
      private int rear; //队列尾
      private int[] arr; //模拟队列的数组
  
      //构造器创建队列
      public ArrayQueue(int arrMaxSize) {
          MaxSize = arrMaxSize;
          arr = new int[MaxSize];
          front = -1;
          rear = -1;
      }
  
      //判断队列是否满
      public boolean isFull() {
          return rear == MaxSize - 1;
      }
  
      //判断队列是否空
      public boolean isEmpty() {
          return rear == front;
      }
  
      //添加数据
      public void addQueue(int n) {
          //判断队列是否为满
          if (isFull()) {
              System.out.println("队列满了,无法添加数组");
              return;
          }
          arr[++rear] = n;
  
      }
  
      //取出数组
      public int getQueue() {
          //判断队列是否为空
          if (isEmpty()) {
              throw new RuntimeException("队列为空，没有数组！");
          }
  
          return arr[++front];
      }
  
      //显示队列的所有数据
      public void showQueue() {
          //判断队列是否为空
          if (isEmpty()) {
              throw new RuntimeException("队列为空，无法遍历");
  
          }
          for (int data : arr) {
              System.out.println(data);
          }
  
  
      }
  
      //显示队列的头部
  
      public void headQueue() {
          //判断是否为空
          if (isEmpty()) {
              throw new RuntimeException("队列为空");
          }
  
          System.out.println("队列的头部为:" + arr[front + 1]);
      }
  
  
  }
  //目前数组使用一次就不能用了，没有实现复用的效果
  //改进成一个环形的队列
  
  
  
  ```

- 数组模拟环形代码

  ```java
  package com.clost.sparsearray;
  
  import java.util.Scanner;
  
  /**
   * @author clost
   * @date 2022/9/3 11:32
   */
  public class CircleArrayDemo {
  
      public static void main(String[] args) {
          //创建队列
  
          CircleArray circleArray = new CircleArray(4);
          char key = ' '; //接收用户输入
          Scanner scanner = new Scanner(System.in);
          int choice;
          boolean flag = true;
          while (flag) {
              System.out.println("1.添加数据进队列");
              System.out.println("2.取出数据");
              System.out.println("3.显示队列中的所有数据");
              System.out.println("4.显示队列头数据");
              System.out.println("5.退出");
              System.out.println("请输选择你的操作");
              choice = scanner.nextInt();
  
              switch (choice) {
                  case 1 -> {
                      System.out.println("请输入你要添加的数据");
                      circleArray.addQueue(scanner.nextInt());
                  }
                  case 2 -> System.out.println(circleArray.getQueue());
                  case 3 -> circleArray.showQueue();
                  case 4 -> circleArray.headQueue();
                  case 5 -> flag = false;
                  default -> System.out.println("输入有误，请重新输入");
              }
          }
      }
  }
  
  
  class CircleArray {
      private int MaxSize;//数组最大容量
      private int front; //队列头
      private int rear; //队列尾
      private int[] arr; //模拟队列的数组
  
      public CircleArray(int arrMaxsize) {
          MaxSize = arrMaxsize;
          arr = new int[MaxSize];
      }
  
      //判断队列是否满
      public boolean isFull() {
          return (rear + 1 + MaxSize) % MaxSize == front;
      }
  
      //判断队列是否空
      public boolean isEmpty() {
          return rear == front;
      }
  
      //添加数据
      public void addQueue(int n) {
          //判断队列是否为满
          if (isFull()) {
              System.out.println("队列满了,无法添加数组");
              return;
          }
          arr[rear++] = n;
          rear = rear % MaxSize;
  
      }
  
      //取出数组
      public int getQueue() {
          //判断队列是否为空
          if (isEmpty()) {
              throw new RuntimeException("队列为空，没有数组！");
          }
  
          int value = arr[front];
          front = (front + 1) % MaxSize;
          return value;
      }
  
      //返回当前队列有效数据的个数
      public int size() {
          return (rear + MaxSize - front) % MaxSize;
      }
  
  
      //显示队列的所有数据
      public void showQueue() {
          //判断队列是否为空
          if (isEmpty()) {
              throw new RuntimeException("队列为空，无法遍历");
  
          }
  
          for (int i = front; i < size(); i++) {
              System.out.printf("arr[%d]=%d\n", i % MaxSize, arr[i % MaxSize]);
          }
  
  
      }
  
      //显示队列的头部
  
      public void headQueue() {
          //判断是否为空
          if (isEmpty()) {
              throw new RuntimeException("队列为空");
          }
  
          System.out.println("队列的头部为:" + arr[front]);
      }
  
  
  }
  
  ```

 ### 链表（LinkedList）：

- 链表是有序的列表

- 链表的以节点的方式来存储

- 每个节点包含data域、next域

- 各个节点不一定是连续存储的

- 链表分带头结点的链表和不带头结点的链表，根据实际需求来确定

- 单链表的创建和遍历

  ```java
  package com.clost.LinkList;
  
  /**
   * @author clost
   * @date 2022/9/4 10:07
   */
  public class SingleLinkedListDemo {
  
      public static void main(String[] args) {
  
          //创建节点
          HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
          HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
          HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
          HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
  
          //创建单链表
          SingleLinkListed singleLinkListed = new SingleLinkListed();
  
          //添加元素
          singleLinkListed.add(hero1);
          singleLinkListed.add(hero2);
          singleLinkListed.add(hero3);
          singleLinkListed.add(hero4);
          //遍历显示
          singleLinkListed.list();
      }
  
  }
  
  
  class SingleLinkListed{
      //初始化头结点
      private HeroNode head = new HeroNode(0,"","");
  
  
      //添加
      public void add(HeroNode heroNode){
          HeroNode temp = head;
  
          while (true){
              if (temp.next == null){
                  break;
              }
              temp = temp.next;
          }
          temp.next = heroNode;
      }
  
      //显示链表，遍历
      public void list(){
          //判断链表是否为空
          if (head.next == null){
              System.out.println("链表为空！");
              return;
          }
          HeroNode temp = head.next;
  
          while (true){
              if (temp == null){
                  break;
              }
              System.out.println(temp);
              temp = temp.next;
          }
      }
  }
  
  
  //定义HeroNode，每个HeroNode对象就是一个节点
  
  class HeroNode{
  
      public int no;
      public String name;
      public String nickName;
      public HeroNode next;
  
      public HeroNode(int no, String name, String nickName) {
          this.no = no;
          this.name = name;
          this.nickName = nickName;
      }
  
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "no=" + no +
                  ", name='" + name + '\'' +
                  ", nickName='" + nickName + '\'' +
                  '}';
      }
  }
  ```
  
- 单链表按顺序插入

  ```java
  package com.clost.LinkList;
  
  /**
   * @author clost
   * @date 2022/9/4 10:07
   */
  public class SingleLinkedListDemo {
  
      public static void main(String[] args) {
  
          //创建节点
          HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
          HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
          HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
          HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
  
          //创建单链表
          SingleLinkListed singleLinkListed = new SingleLinkListed();
  
          //添加元素
          singleLinkListed.addByOrder(hero1);
          singleLinkListed.addByOrder(hero3);
          singleLinkListed.addByOrder(hero2);
          singleLinkListed.addByOrder(hero4);
          singleLinkListed.addByOrder(hero4);
          //遍历显示
          singleLinkListed.list();
      }
  
  }
  
  
  class SingleLinkListed {
      //初始化头结点
      private HeroNode head = new HeroNode(0, "", "");
  
  
      //添加
      public void add(HeroNode heroNode) {
          HeroNode temp = head;
  
          while (true) {
              if (temp.next == null) {
                  break;
              }
              temp = temp.next;
          }
          temp.next = heroNode;
      }
  
      //按顺序添加
      public void addByOrder(HeroNode heroNode) {
  
          HeroNode temp = head;
          boolean flag = false;
  
          while (true) {
              if (temp.next == null) {
                  break;
              }
              if (temp.next.no > heroNode.no) {
                  break;
              } else if (temp.next.no == heroNode.no) {
  
                  flag = true;
                  break;
              }
              temp = temp.next;
  
  
          }
          if (flag) {
              System.out.println("编号已经存在,不能加入");
          } else {
              heroNode.next = temp.next;
              temp.next = heroNode;
          }
  
  
      }
  
      //显示链表，遍历
      public void list() {
          //判断链表是否为空
          if (head.next == null) {
              System.out.println("链表为空！");
              return;
          }
          HeroNode temp = head.next;
  
          while (true) {
              if (temp == null) {
                  break;
              }
              System.out.println(temp);
              temp = temp.next;
          }
      }
  }
  
  
  //定义HeroNode，每个HeroNode对象就是一个节点
  
  class HeroNode {
  
      public int no;
      public String name;
      public String nickName;
      public HeroNode next;
  
      public HeroNode(int no, String name, String nickName) {
          this.no = no;
          this.name = name;
          this.nickName = nickName;
      }
  
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "no=" + no +
                  ", name='" + name + '\'' +
                  ", nickName='" + nickName + '\'' +
                  '}';
      }
  }
  ```

- 单链表节点修改

  ```java
  package com.clost.LinkList;
  
  /**
   * @author clost
   * @date 2022/9/4 10:07
   */
  public class SingleLinkedListDemo {
  
      public static void main(String[] args) {
  
          //创建节点
          HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
          HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
          HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
          HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
  
          //创建单链表
          SingleLinkListed singleLinkListed = new SingleLinkListed();
  
          //添加元素
          singleLinkListed.addByOrder(hero1);
          singleLinkListed.addByOrder(hero3);
          singleLinkListed.addByOrder(hero2);
          singleLinkListed.addByOrder(hero4);
  
          singleLinkListed.list();
          singleLinkListed.delete(1);
  
          System.out.println("删除后");
          singleLinkListed.list();
      }
  
  }
  
  
  class SingleLinkListed {
      //初始化头结点
      private HeroNode head = new HeroNode(0, "", "");
  
  
      //添加
      public void add(HeroNode heroNode) {
          HeroNode temp = head;
  
          while (true) {
              if (temp.next == null) {
                  break;
              }
              temp = temp.next;
          }
          temp.next = heroNode;
      }
  
      //按顺序添加
      public void addByOrder(HeroNode heroNode) {
  
          HeroNode temp = head;
          boolean flag = false;
  
          while (true) {
              if (temp.next == null) {
                  break;
              }
              if (temp.next.no > heroNode.no) {
                  break;
              } else if (temp.next.no == heroNode.no) {
  
                  flag = true;
                  break;
              }
              temp = temp.next;
  
  
          }
          if (flag) {
              System.out.println("编号已经存在,不能加入");
          } else {
              heroNode.next = temp.next;
              temp.next = heroNode;
          }
  
  
      }
  
      //根据newHeroNode.no来修改
  
      public void update(HeroNode newHeroNode) {
          HeroNode temp = head.next;
          while (true) {
              if (temp == null) {
                  System.out.println("没有找到此节点");
                  ;
                  break;
              }
              if (temp.no == newHeroNode.no) {
                  temp.name = newHeroNode.name;
                  temp.nickName = newHeroNode.nickName;
              }
              temp = temp.next;
  
          }
  
      }
      //删除节点
      public void delete(int no){
          HeroNode temp = head;
  
          while (true){
              if (temp.next == null){
                  break;
              }
              if (temp.next.no == no){
                  temp.next = temp.next.next;
                  break;
              }
  
              temp = temp.next;
          }
      }
      //显示链表，遍历
      public void list() {
          //判断链表是否为空
          if (head.next == null) {
              System.out.println("链表为空！");
              return;
          }
          HeroNode temp = head.next;
  
          while (true) {
              if (temp == null) {
                  break;
              }
              System.out.println(temp);
              temp = temp.next;
          }
      }
  }
  
  
  //定义HeroNode，每个HeroNode对象就是一个节点
  
  class HeroNode {
  
      public int no;
      public String name;
      public String nickName;
      public HeroNode next;
  
      public HeroNode(int no, String name, String nickName) {
          this.no = no;
          this.name = name;
          this.nickName = nickName;
      }
  
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "no=" + no +
                  ", name='" + name + '\'' +
                  ", nickName='" + nickName + '\'' +
                  '}';
      }
  }
  ```

- 面试题

  ```markdown 
  单链表的常见面试题：
  - 求的单链表中有效结点的个数
  - 查找单链表中的倒数第k个结点
  - 单链表的反转
  - 从头到尾打印单链表（要求，反向遍历 或 Stack栈）
  - 合并两个有效的单链表，合并后的链表依旧有顺序

​	

### 双向循环链表:

- 单向链表查找方向只能是一个方向，而双向链表可以向前或者向后查找

- 单项链表不能自我删除，需要借助辅助节点，而双向链表可以自我删除

- 应用实例

  ```java
  package com.clost.LinkList;
  
  /**
   * @author clost
   * @date 2022/9/5 22:36
   */
  public class DoubleLinkedListDemo {
  
      public static void main(String[] args) {
  
          System.out.println("双向链表测试");
          //创建节点
          HeroNode1 hero1 = new HeroNode1(1, "宋江", "及时雨");
          HeroNode1 hero2 = new HeroNode1(2, "卢俊义", "玉麒麟");
          HeroNode1 hero3 = new HeroNode1(3, "吴用", "智多星");
          HeroNode1 hero4 = new HeroNode1(4, "林冲", "豹子头");
  
          DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
  
          doubleLinkedList.add(hero1);
          doubleLinkedList.add(hero2);
          doubleLinkedList.add(hero3);
          doubleLinkedList.add(hero4);
  
          doubleLinkedList.list();
  
          //修改
          HeroNode1 newHeroNode = new HeroNode1(4, "公孙胜", "入云龙");
          doubleLinkedList.update(newHeroNode);
  
          System.out.println("修改后的链表是");
          doubleLinkedList.list();
  
          //删除
          doubleLinkedList.delete(4);
          System.out.println("删除后的链表");
          doubleLinkedList.list();
      }
  
  }
  
  
  class DoubleLinkedList {
      private HeroNode1 head = new HeroNode1(0, "", "");
  
      //添加
      public void add(HeroNode1 heroNode1) {
          HeroNode1 temp = head;
  
          while (true) {
              if (temp.next == null) {
                  break;
              }
              temp = temp.next;
          }
          temp.next = heroNode1;
          heroNode1.pre = temp;
      }
  
      //修改
      public void update(HeroNode1 heroNode1) {
          HeroNode1 temp = head.next;
          boolean flag = false;
  
          while (true) {
              if (temp == null) {
                  break;
              }
              if (temp.no == heroNode1.no) {
                  flag = true;
                  break;
              }
  
              temp = temp.next;
  
          }
          if (flag) {
              temp.name = heroNode1.name;
              temp.nickName = heroNode1.nickName;
          } else {
              System.out.println("没有找到此结点");
          }
  
      }
  
  
      //删除节点
      public void delete(int no) {
          HeroNode1 temp = head.next;
  
          if (head.next == null) {
              System.out.println("链表为空");
              return;
          }
          boolean flag = false;
  
          while (temp != null) {
              if (temp.no == no) {
                  flag = true;
                  break;
              }
              temp = temp.next;
          }
  
          if (flag) {
              temp.pre.next = temp.next;
              if (temp.next != null) {
                  temp.next.pre = temp.pre;
              }
  
          } else {
              System.out.println("没有找到此节点");
          }
  
      }
  
      //遍历链表
      public void list() {
          //判断链表是否为空
          if (head.next == null) {
              System.out.println("链表为空！");
              return;
          }
          HeroNode1 temp = head.next;
  
          while (true) {
              if (temp == null) {
                  break;
              }
              System.out.println(temp);
              temp = temp.next;
          }
      }
  
      public HeroNode1 getHead() {
          return head;
      }
  
  
  }
  
  
  class HeroNode1 {
      public int no;
      public String name;
      public String nickName;
      public HeroNode1 next;
      public HeroNode1 pre;
  
      public HeroNode1(int no, String name, String nickName) {
          this.no = no;
          this.name = name;
          this.nickName = nickName;
      }
  
      @Override
      public String toString() {
          return "HeroNode1{" +
                  "no=" + no +
                  ", name='" + name + '\'' +
                  ", nickName='" + nickName + '\'' +
                  '}';
      }
  }
  ```

**约瑟夫问题：**

- 分析

  ```tex
  1.创建一个辅助节点 helper
  2.移动first到启示位置==》first = first.next  相当于移动 m -1次（m:启示位置，K间隔，nums:链表的元素总数）
  3.始终保证helper.next = first   第一步让helper指向first 循环移动helper 直至 helper.next = first
  4.first 和 helper同时移动k-1次，此时first即为要出圈的元素
  5.first出圈，first = first.next helper.next = first
  6.判断first是不是圈中的最后一个元素,是的话退出循环    first == first.next
  ```

- 代码实现

  ```java
  package com.clost.LinkList;
  
  /**
   * @author clost
   * @date 2022/9/8 8:17
   */
  public class Josephu {
  
      public static void main(String[] args) {
          CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
          circleSingleLinkedList.addBoy(25);
  //        circleSingleLinkedList.list();
          circleSingleLinkedList.countBoy(1, 2, 25);
  
      }
  
  
  }
  
  
  class CircleSingleLinkedList {
      private Boy first = new Boy(-1);
  
      public void addBoy(int nums) {
          if (nums < 1) {
              System.out.println("输入有误");
          }
  
          Boy curBoy = null;
          for (int i = 1; i <= nums; i++) {
  
              Boy boy = new Boy(i);
              if (i == 1) {
                  first = boy;
                  first.setNext(first);
              } else {
                  curBoy.setNext(boy);
                  boy.setNext(first);
              }
              curBoy = boy;
          }
  
      }
  
      public void list() {
          if (first == null) {
              System.out.println("链表为空");
              return;
          }
  
          Boy curBoy = first;
          while (true) {
              System.out.println(curBoy);
              if (curBoy.getNext() == first) {
                  break;
              }
              curBoy = curBoy.getNext();
          }
      }
  
  
      public void countBoy(int startNo, int countNum, int nums) {
  
          if (first == null || startNo < 1 || startNo > nums) {
              System.out.println("参数有误");
              return;
          }
          Boy helper = first;
  
  
          while (true){
              if (helper.getNext() == first){
                  break;
              }
              helper = helper.getNext();
          }
  
          for (int i = 1; i < startNo; i++) {
              first = first.getNext();
              helper = helper.getNext();
  
          }
  
  
  
          while (true) {
  
  
              for (int i = 0; i < countNum - 1; i++) {
                  first = first.getNext();
                  helper = helper.getNext();
              }
              System.out.println(first);
              if (first.getNext() == first) {
                  break;
              }
  
  
              first = first.getNext();
              helper.setNext(first);
  
  
          }
  
  
  
      }
  }
  
  
  class Boy {
      private int no;
      private Boy next;
  
      public Boy(int no) {
          this.no = no;
      }
  
      public int getNo() {
          return no;
      }
  
      public void setNo(int no) {
          this.no = no;
      }
  
      public Boy getNext() {
          return next;
      }
  
      public void setNext(Boy next) {
          this.next = next;
      }
  
      @Override
      public String toString() {
          return "Boy{" +
                  "no=" + no +
                  '}';
      }
  }
  
  ```

### 栈

**栈的应用场景：**

- 子程序调用
- 处理递归调用
- 表达式转换
- 二叉树的遍历
- 图形的深度优先

**数组模拟栈：**

- 定义一个Top表示栈顶,初始为-1

- 入栈时候：栈顶上移，数据入栈   top++; stack[top] = value

- 出栈时候: 数据出栈,栈顶下移 value = stack[top]; top--; 

- ```java
  package com.clost.stack;
  
  /**
   * @author clost
   * @date 2022/9/11 8:54
   */
  public class ArrayStackDemo {
  
      public static void main(String[] args) {
          ArrayStack arrayStack = new ArrayStack(4);
          arrayStack.push(1);
          arrayStack.push(2);
          arrayStack.push(3);
          arrayStack.push(4);
          arrayStack.list();
      }
  
  
  }
  
  
  class ArrayStack {
      private int maxSize;//栈的大小
      private int[] stack;  //数组模拟栈
      private int top = -1;//top表示栈顶，初始化为-1
  
      //构造器
      public ArrayStack(int maxSize) {
          this.maxSize = maxSize;
          stack = new int[maxSize];
      }
  
      //判断栈满
      public boolean isFull() {
  
          return top == maxSize - 1;
      }
  
      //判断栈空
      public boolean isEmpty() {
          return top == -1;
      }
  
      //入栈
      public void push(int values) {
          if (isFull()) {
              System.out.println("栈满!");
              return;
          }
          stack[++top] = values;
  
  
      }
  
      //出栈
      public int pop() {
          if (isEmpty()) {
              throw new RuntimeException("栈空");
          }
          return stack[top--];
      }
  
      //遍历栈
  
      public void list(){
          if(isEmpty()){
              System.out.println("栈空");
          }
  
          while(top > -1){
              System.out.println(stack[top--]);
          }
  
      }
  
  
  }
  
  ```

**表达式：**

- 前缀表达式(波兰表达式)

  ```tex
  例子:(3+4)*5-6  表达式为:-x+3456
  1.从右到左扫描，6，5，4，3压入堆栈
  2.遇到运算符，弹出3,4  3+4=7 7入栈
  3.遇到运算符 弹出 7，5 7*5=35 35入栈
  4.遇到运算符 - 弹出35,6 35-6=29 最终计算结果为29
  ```

- 中缀表达式

  ```tex
  中缀表达式是最常见的运算表达式
  中缀表达式的求值是我们人最熟悉的，但是对于计算机来说不好操作，要判断运算符的优先级
  在计算中通常把中缀表达式转化成后缀表达式
  ```

- 后缀表达式(逆波兰表达式)

  ```tex
  例子:(3+4)*5-6 表达式为:34+5x6-
  1.从左到右扫描，将3和4压入堆栈
  2.遇到运算符，弹出3,4 3+4=7 7入栈
  3.将5入栈
  4.遇到运算符，弹出5,7  5*7=35,35入栈
  5.将6入栈
  6.遇到运算符，弹出6,35 35-6=29
  ```

**逆波兰表达式计算器:**

- ```java
  package com.clost.stack;
  
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Stack;
  
  /**
   * @author clost
   * @date 2022/9/11 10:37
   */
  public class PolandNotation {
  
      public static void main(String[] args) {
          //定义逆波兰表达式
          //(3+4)x5-6 ==>  3 4 + 5 x 6 -
  
          String suffixExpression = "30 4 + 5 * 6 -";
          List<String> newExpression = getListString(suffixExpression);
          System.out.println(newExpression);
  
          System.out.println("计算结果为: "+calculate(newExpression));
  
      }
  
      public static List<String> getListString(String suffixExpression) {
          String[] newExpression = suffixExpression.split(" ");
          ArrayList<String> list = new ArrayList<>();
          for (String item : newExpression) {
              list.add(item);
          }
          return list;
      }
  
      public static int calculate(List<String> list) {
  
          //创建一个栈
          Stack<String> stack = new Stack<>();
          for (String item : list) {
              if (item.matches("\\d+")) {
                  stack.push(item);
              } else {
                  //取出两个数，运算后再入栈
                  int num1 = Integer.parseInt(stack.pop());
                  int num2 = Integer.parseInt(stack.pop());
                  int result = 0;
                  switch (item) {
                      case "+" -> result = num2 + num1;
                      case "-" -> result = num2 - num1;
                      case "*" -> result = num2 * num1;
                      case "/" -> result = num2 / num1;
                      default -> throw new RuntimeException("输出的表达式有误!");
                  }
  
                  stack.push(result + "");
  
              }
          }
  
          //最后留在栈中的数据即是计算结果
          return Integer.parseInt(stack.pop());
      }
  
  }
  
  ```

**中缀转后缀表达式：**

- ```tex
  中缀表达式转 1+((2+3)X4)-5
  1.初始化两个栈：运算符栈s1，存储中间结果的栈s2
  2.从左到右扫描中缀表达式
  3.遇到操作数时候，将其压入s2
  4.遇到运算符时，与其比较s1栈顶运算符的优先级：
   (1).如果s1为空，或栈顶运算符为左括号"(",则直接将此运算符入栈
   (2).否则，若优先级比栈顶运算符高，也将运算符压入s1
   (3).否则，将s1栈顶的运算符弹出并压入到s2中，再次回到步骤4.1
  5.遇到括号时候
   (1).如果是左括号"(",直接压入s1
   (2).如果是右括号“)”,则依次弹出s1栈顶的运算符，并压入到s2中，直到遇到左括号为止，此时消除掉一对括号
  6.重复步骤2到5直到表达式的最右边
  7.将s1中剩余的运算符依次弹出压入到s2中
  8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
  
  
  ```

- ![中缀表达式转后缀表达式](D:\截图\数据结构与算法\中缀表达式转后缀表达式.png)

- 完整版

  ```java
  package com.clost.stack;
  
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Stack;
  
  /**
   * @author clost
   * @date 2022/9/11 10:37
   */
  public class PolandNotation {
  
      public static void main(String[] args) {
          //定义逆波兰表达式
          //(3+4)x5-6 ==>  3 4 + 5 x 6 -
  
          String suffixExpression = "30 4 + 5 * 6 -";
          List<String> newExpression = getListString(suffixExpression);
          System.out.println(newExpression);
  //        System.out.println("计算结果为: "+calculate(newExpression));
          String expression = "1+((2+3)*4)-5";
          List<String> infixExpressionList = toInfixExpressionList(expression);
          System.out.println(infixExpressionList);
          List<String> pa = parseSuffixExpressionList(infixExpressionList);
          System.out.println("后缀表达式对应的List");
          System.out.println(pa);
  
      }
  
  
      public static List<String> parseSuffixExpressionList(List<String> list) {
  
          Stack<String> stack1 = new Stack<>();
  
          ArrayList<String> stack2 = new ArrayList<>();
  
          for (String item : list) {
              if (item.matches("\\d+")) {
                  stack2.add(item);
              } else if (item.equals("(")) {
                  stack1.push(item);
              } else if (item.equals(")")) {
                  while (!stack1.peek().equals("(")) {
                      stack2.add(stack1.pop());
                  }
                  stack1.pop();
              } else {
  
                  while (stack1.size() != 0 && Operation.getValue(stack1.peek()) >= Operation.getValue(item)) {
                      stack2.add(stack1.pop());
                  }
                  stack1.push(item);
  
              }
          }
  
          while (stack1.size() != 0) {
              stack2.add(stack1.pop());
          }
  
  
          return stack2;
      }
  
      public static List<String> toInfixExpressionList(String s) {
          List<String> list = new ArrayList<String>();
          String str;
          int i = 0;
  
          do {
              char c = s.charAt(i);
              if (c < 48 || c > 57) {
                  list.add(c + "");
                  i++;
              } else {
                  str = "";
                  while (i < s.length() && (c = s.charAt(i)) >= 48 && (c = s.charAt(i)) <= 57) {
                      str += c;
                      i++;
                  }
  
                  list.add(str);
  
              }
          } while (i < s.length());
  
  
          return list;
  
  
      }
  
      public static List<String> getListString(String suffixExpression) {
          String[] newExpression = suffixExpression.split(" ");
          ArrayList<String> list = new ArrayList<>();
          for (String item : newExpression) {
              list.add(item);
          }
          return list;
      }
  
      public static int calculate(List<String> list) {
  
          //创建一个栈
          Stack<String> stack = new Stack<>();
          for (String item : list) {
              if (item.matches("\\d+")) {
                  stack.push(item);
              } else {
                  //取出两个数，运算后再入栈
                  int num1 = Integer.parseInt(stack.pop());
                  int num2 = Integer.parseInt(stack.pop());
                  int result = 0;
                  switch (item) {
                      case "+" -> result = num2 + num1;
                      case "-" -> result = num2 - num1;
                      case "*" -> result = num2 * num1;
                      case "/" -> result = num2 / num1;
                      default -> throw new RuntimeException("输出的表达式有误!");
                  }
  
                  stack.push(result + "");
  
              }
          }
  
          //最后留在栈中的数据即是计算结果
          return Integer.parseInt(stack.pop());
      }
  
  }
  
  class Operation {
      private static int ADD = 1;
      private static int SUB = 1;
      private static int MUL = 2;
      private static int DIV = 2;
  
  
      public static int getValue(String operation) {
          int result = 0;
  
          switch (operation) {
              case "+" -> result = ADD;
              case "-" -> result = SUB;
              case "*" -> result = MUL;
              case "/" -> result = DIV;
              default -> System.out.println("error");
          }
  
  
          return result;
      }
  }
  
  ```

### 递归

**递归的概念：**

递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于解决复杂问题，同时让代码更简洁

**递归调用机制:**

- 当程序执行到一个方法时，就会开辟一个独立空间(栈)
- 每个空间的数据(局部变量)，是独立的，不会相互影响
- 如果方法中使用的是引用类型的变量，就会共享该引用类型的数据
- 递归必须向退出递归的条件逼近，不然就无限递归了

![递归](D:\截图\数据结构与算法\递归.png)



**迷宫问题：**

![迷宫](D:\截图\数据结构与算法\迷宫.png)





- 代码实现

  ```java
  package com.clost.recursion;
  
  import com.sun.source.tree.IfTree;
  
  /**
   * @author clost
   * @date 2022/9/14 21:44
   */
  public class Maze {
  
      public static void main(String[] args) {
  
          //创建一个二维数组，模拟迷宫
          //地图
  
          int[][] map = new int[8][7];
  
          for (int i = 0; i < 7; i++) {
              map[0][i] = 1;
              map[7][i] = 1;
          }
  
          for (int i = 0; i < 8; i++) {
              map[i][0] = 1;
              map[i][6] = 1;
          }
          map[3][1] = 1;
          map[3][2] = 1;
  
          getWay(map,1,1);
  
          for (int[] row : map) {
              for (int item : row) {
                  System.out.print(item + "\t");
              }
  
              System.out.println();
  
          }
  
  
      }
  
      /**
       *
       * @return
       */
  
      public static boolean getWay(int[][] map, int i, int j){
  
          if (map[6][5] == 2){
              return true;
          }else {
              if(map[i][j] == 0){
                  map[i][j] = 2;
                  if(getWay(map,i + 1,j)){
                      return true;
                  }else if(getWay(map,i,j + 1)){
                      return true;
                  }else if(getWay(map,i - 1,j)){
                      return false;
                  }else if(getWay(map,i,j - 1)){
                      return true;
                  }else {
                      map[i][j] = 3;
                      return false;
                  }
              }else {
                  return false;
              }
          }
      }
  }
  
  ```

**八皇后：**(回溯算法)

**问题描述**

![八皇后](D:\笔记\笔记\img\八皇后.png)

**思路分析**：

- 第一个皇后放第一行第一列
- 第二个皇后遍历判断是否冲突，找到一个ok的位置
- 第三皇后，判断是否与前两列的皇后是都冲突，找到一个ok的位置，以此类推
- 当找到一个正确解的时候退回到上一个栈也就是开始回溯，尝试寻找第一个皇后放第一列的所有正确解
- 然后继续找第一个皇后放第二列的所有结果，以此类推找到所有正确结果

**代码实现**:

```java
package com.clost.recursion;

/**
 * @author clost
 * @date 2022/9/15 9:23
 */
public class Queen8 {


    //皇后的数量
    public static int maxQueen = 8;
    //用来存放游戏的结果,数组的下标代表第n+1行
    public static int[] resArr = new int[maxQueen];

    public static void main(String[] args) {


        setQueen(0);
    }


    //判断第n个皇后是否与之前摆放的皇后冲突
    //判断是否在同列或统一对角线上
    public static boolean judge(int n) {

        for (int i = 0; i < n; i++) {
            if (resArr[i] == resArr[n] || (n - i) == Math.abs(resArr[n] - resArr[i])) {
                return false;
            }
        }

        return true;
    }

    //打印一种解法
    public static void printRes() {
        for (int i = 0; i < resArr.length; i++) {
            System.out.print(resArr[i] + " ");
        }
        System.out.println();
    }


    public static void setQueen(int n) {
        if (n == maxQueen) {
            printRes();
            return;
        }
        for (int i = 0; i < maxQueen; i++) {
            resArr[n] = i;
            if (judge(n)) {
                setQueen(n + 1);
            }
        }

    }


}

```

**小结**：

- 理解递归的调用，每一次递归都开辟一个新的栈空间，发现冲突时候回到上一个栈中，找到正确解时候返回上一个栈中
- 返回上一个栈中也就是==回溯==，所谓回溯就是尝试所有解，发现走不通回到上一个栈继续走其他路
- 此种解法为暴力解法，重点理解回溯思想

### 排序算法

**排序算法的介绍**：

排序是将一组数据，依指定的顺序进行排列的过程

**排序的分类**：

- 内部排序：数据加载到内存中进行排序

- 外部排序：数据量过大，需要借助外部存储进行排序

  ![排序](D:\笔记\笔记\img\排序.png)

#### 算法的时间复杂度：

**度量一个程序（算法）执行时间的两种方法**

- 事后统计法

  需要实际运行该程序，依赖计算机的硬件 ==需要在同一计算机相同的状态下运行==

- 事前估计法

  通过分析某个算法的时间复杂度来判断哪个算法更优

**时间频度**

​	一个算法花费的时间与算法中语句的执行次数成正比，执行的次数越多，花费的时间越多

==一个算法中的语句中语句执行次称为语句频度或时间频度== 记作T(n)

```java
//例子
//计算1-100所数字之和
//方法1 
	int total = 0;
	int end = 100;
	for(int i = 1; i < end; i++){
        total += 1;
    }
	//T(n) = n + 1
//方法二
	total = (1 + end) * end / 2;
	//T(n) = 1
```



![120b6a1700e551b8f8900d3fcbae581](C:\Users\clost\AppData\Local\Temp\WeChat Files\120b6a1700e551b8f8900d3fcbae581.png)



**结论**

​	计算时间复杂度中，==常数项可以忽略==，==低次项可以忽略==，==高次项系数可以忽略==

**时间复杂度**：

![时间复杂度](D:\笔记\笔记\img\时间复杂度.png)

**常见的时间复杂度**

- 常数阶O(1)
- 对数阶O(log~2~n)
- 线性阶O(n)
- 线性对数阶O(nlog~2~n)
- 平方阶(n^2^)
- 立方阶(n^3^)
- k次方阶O(n^k^)
- 指数阶O(2^n^)1

**平均时间复杂度和最坏时间复杂度**

- 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
- 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂

![image-20221115084304227](C:\Users\clost\AppData\Roaming\Typora\typora-user-images\image-20221115084304227.png)

#### 算法的空间复杂度

- 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数
- 在做算法分析时，**主要讨论的是时间复杂度**

#### 冒泡排序

**基本介绍**

​	冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较

相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒





![冒泡](D:\笔记\笔记\img\冒泡.png)



​	**代码实现**

```java
package com.clost.sort;

/**
 * @author clost
 * @date 2022/11/15 8:53
 */
public class BubbleSort {
    public static void main(String[] args) {

        int[] arr = {3, 9, -1, 10, -2};

        for (int i = 0; i < arr.length - 1; i++) {
            boolean flag = true;

            for (int j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    flag = false;
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }

            if (flag) {
                break;
            }
        }


        for (int item : arr) {
            System.out.print(item + "\t");
        }

    }
}

```

**总结**：

- 冒泡排序过程中不断比较相邻元素，如果逆序就交换位置
- ==如果一趟比较中一次都没交换，说明已经排序完毕，应结束循环==

#### 选择排序

**基本介绍**

​	选择排序是一种简单的排序方法，基本思想就是：第一轮比较0到n中的一个最小的数与第一个数交换位置，第二轮比较1到n中的最小的数与第二个交换位置，以此类推，循环比较n-1次后会得到一个有序序列





![选择排序](D:\笔记\笔记\img\选择排序.png)



**代码实现**

```java
package com.clost.sort;

/**
 * @author clost
 * @date 2022/11/15 14:40
 */

@SuppressWarnings({"all"})
public class SelectSort {
    public static void main(String[] args) {

        int[] arr = {101, 34, 119, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1, 1, 1, 1, 1};
        System.out.println("排列前的数组为：");
        for (int item : arr) {
            System.out.print(item + "\t");
        }


        for (int i = 0; i < arr.length - 1; i++) {
            int min = arr[i];
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {
                    min = arr[j];
                    minIndex = j;
                }
            }

            if(minIndex != i){
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }


        System.out.println("排列后的数组为：");
        for (int item : arr) {
            System.out.print(item + "\t");
        }

    }
}

```

**小结**

- 选择排序的时间复杂度依旧为O(n^2^),但实际速度比冒泡排序快
- 由于没有频繁的交换位置，也就是用空间换取了时间

#### 插入排序

**基本介绍**

​	插入排序（Insertion Sorting）的**基本思想**是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。



![插入排序](D:\笔记\笔记\img\插入排序.png)

**代码实现**

```java
package com.clost.sort;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @author clost
 * @date 2022/11/15 15:13
 */
public class InsertSort {
    public static void main(String[] args) {
        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)(Math.random()*8000000);
        }
        
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

        System.out.println("排序前时间是:" + simpleDateFormat.format(new Date()));


        for (int i = 1; i < arr.length; i++) {

            int insertVal = arr[i];
            int insertIndex = i -1 ;
            while(insertIndex >= 0 && insertVal < arr[insertIndex]){

                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            arr[insertIndex + 1] = insertVal;

        }

		
        //双重for循环写法
        for (int i = 1; i < arr.length; i++) {

            int insertVal = arr[i];
            int insertIndex = i -1;
            for(int j = i - 1; j >= 0; j--){

                if(insertVal < arr[j]){
                    insertIndex--;
                    arr[j+1] = arr[j];
                }
            }
            arr[insertIndex + 1] = insertVal;
        }

        System.out.println("排序后时间是:" + simpleDateFormat.format(new Date()));



    }
}

```

**小结**

- 插入排序与冒泡排序不同，冒泡排序是比较数值后交换位置，插入排序是比较数值后，找到位置，使元素依次后移给要插入的元素腾出一个位置
- 插入排序存在的问题，插入数是比较小或者较大的时候。移动的次数明显增多，对效率有影响

#### 希尔排序









